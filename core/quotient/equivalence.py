from future import annotations
from typing import Dict, Hashable, Iterable, List, Tuple

class Equivalence:
    '''
    Reflexive–symmetric–transitive closure via union–find (disjoint sets).
    Provides:
    - add(x)
    - union(x, y)
    - classes(): list of sets (each an equivalence class)
    - representative(x): canonical rep of x
    - relabel(mapping): remap underlying element ids (used after merges)
    '''
def init(self) -> None:
    self.parent: Dict[Hashable, Hashable] = {}
    self.rank: Dict[Hashable, int] = {}

def add(self, x: Hashable) -> None:
    if x not in self.parent:
        self.parent[x] = x
        self.rank[x] = 0

def find(self, x: Hashable) -> Hashable:
    # path compression
    px = self.parent.get(x, None)
    if px is None:
        self.add(x)
        return x
    if px != x:
        self.parent[x] = self.find(px)
    return self.parent[x]

def union(self, a: Hashable, b: Hashable) -> None:
    ra, rb = self.find(a), self.find(b)
    if ra == rb:
        return
    # union by rank
    if self.rank[ra] < self.rank[rb]:
        self.parent[ra] = rb
    elif self.rank[rb] < self.rank[ra]:
        self.parent[rb] = ra
    else:
        self.parent[rb] = ra
        self.rank[ra] += 1

def classes(self) -> List[Tuple[Hashable, ...]]:
    bins: Dict[Hashable, List[Hashable]] = {}
    for x in list(self.parent.keys()):
        r = self.find(x)
        bins.setdefault(r, []).append(x)
    return [tuple(v) for v in bins.values()]

def representative(self, x: Hashable) -> Hashable:
    return self.find(x)

def relabel(self, mapping: Dict[Hashable, Hashable]) -> None:
    # allow callers to rename primitive ids (e.g., after environment merges)
    new_parent: Dict[Hashable, Hashable] = {}
    new_rank: Dict[Hashable, int] = {}
    for k, v in self.parent.items():
        nk = mapping.get(k, k)
        nv = mapping.get(v, v)
        new_parent[nk] = nv
        new_rank.setdefault(nk, self.rank.get(k, 0))
    self.parent = new_parent
    self.rank = new_rank


    from future import annotations  
from typing import Dict, Hashable, Iterable, Tuple, List

class UnionFind:  
"""  
Simple union–find (disjoint set) with path compression.  
Keys are eventlet identifiers (Hashable).  
"""  
def **init**(self) -> None:  
self.parent: Dict[Hashable, Hashable] = {}  
self.rank: Dict[Hashable, int] = {}

```
def find(self, x: Hashable) -> Hashable:
    if x not in self.parent:
        self.parent[x] = x
        self.rank[x] = 0
        return x
    # path compression
    if self.parent[x] != x:
        self.parent[x] = self.find(self.parent[x])
    return self.parent[x]

def union(self, a: Hashable, b: Hashable) -> Hashable:
    ra, rb = self.find(a), self.find(b)
    if ra == rb:
        return ra
    # union by rank
    if self.rank[ra] < self.rank[rb]:
        ra, rb = rb, ra
    self.parent[rb] = ra
    if self.rank[ra] == self.rank[rb]:
        self.rank[ra] += 1
    return ra
```

def equivalence_classes(pairs: Iterable[Tuple[Hashable, Hashable]]) -> Dict[Hashable, Hashable]:  
"""  
Build equivalence classes from a stream of 'must-merge' pairs (generated by the τ-bend rule).  
Returns a map 'rep[x] = representative' for every seen element x.  
"""  
uf = UnionFind()  
for a, b in pairs:  
uf.union(a, b)  
# normalize representatives  
reps: Dict[Hashable, Hashable] = {}  
for x in list(uf.parent.keys()):  
reps[x] = uf.find(x)  
return reps

def relabel_to_classes(items: Iterable[Hashable], reps: Dict[Hashable, Hashable]) -> Dict[Hashable, Hashable]:  
"""  
Relabel a set of items to their class representatives, using 'reps' map.  
Unseen items become singleton classes.  
"""  
out: Dict[Hashable, Hashable] = {}  
for x in items:  
out[x] = reps.get(x, x)  
return out